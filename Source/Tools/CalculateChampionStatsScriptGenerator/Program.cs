using System.IO;

namespace CalculateChampionStatsScriptGenerator {
	/// <summary>
	///		Because of the number of fields in the stats section of players in the
	///		match history data, I created this utility to write the scripts used
	///		to aggregate the data to avoid typos.
	/// </summary>
	public class Program {
		#region Champion Fields

		private static FieldInfo[] fields = new[] {
			new FieldInfo("champLevel", calculateTotal: false),
			new FieldInfo("kills"),
			new FieldInfo("doubleKills"),
			new FieldInfo("tripleKills"),
			new FieldInfo("quadraKills"),
			new FieldInfo("pentaKills"),
			new FieldInfo("unrealKills"),
			new FieldInfo("largestKillingSpree"),
			new FieldInfo("deaths"),
			new FieldInfo("assists"),
			new FieldInfo("totalDamageDealt"),
			new FieldInfo("totalDamageDealtToChampions"),
			new FieldInfo("totalDamageTaken"),
			new FieldInfo("largestCriticalStrike"),
			new FieldInfo("totalHeal"),
			new FieldInfo("minionsKilled"),
			new FieldInfo("neutralMinionsKilled"),
			new FieldInfo("neutralMinionsKilledTeamJungle"),
			new FieldInfo("neutralMinionsKilledEnemyJungle"),
			new FieldInfo("goldEarned"),
			new FieldInfo("goldSpent"),
			new FieldInfo("magicDamageDealtToChampions"),
			new FieldInfo("physicalDamageDealtToChampions"),
			new FieldInfo("trueDamageDealtToChampions"),
			new FieldInfo("visionWardsBoughtInGame"),
			new FieldInfo("sightWardsBoughtInGame"),
			new FieldInfo("magicDamageDealt"),
			new FieldInfo("physicalDamageDealt"),
			new FieldInfo("trueDamageDealt"),
			new FieldInfo("magicDamageTaken"),
			new FieldInfo("physicalDamageTaken"),
			new FieldInfo("firstBloodKill", true),
			new FieldInfo("firstBloodAssist", true),
			new FieldInfo("firstTowerKill", true),
			new FieldInfo("firstTowerAssist", true),
			new FieldInfo("firstInhibitorKill", true),
			new FieldInfo("firstInhibitorAssist", true),
			new FieldInfo("inhibitorKills"),
			new FieldInfo("towerKills"),
			new FieldInfo("wardsPlaced"),
			new FieldInfo("wardsKilled"),
			new FieldInfo("largestMultiKill"),
			new FieldInfo("killingSprees"),
			new FieldInfo("totalUnitsHealed"),
			new FieldInfo("totalTimeCrowdControlDealt")
		};

		#endregion

		public void Main(string[] args) {
			var permutations = new[] {
				new { ByRegion = true, ByTeam = true, ByChampion = true },
				new { ByRegion = true, ByTeam = true, ByChampion = false },
				new { ByRegion = true, ByTeam = false, ByChampion = true },
				new { ByRegion = true, ByTeam = false, ByChampion = false },
				new { ByRegion = false, ByTeam = true, ByChampion = true },
				new { ByRegion = false, ByTeam = true, ByChampion = false },
				new { ByRegion = false, ByTeam = false, ByChampion = true },
			};

			using (var output = new StreamWriter("GenerateChampionStatsOverTimeG.js")) {
				WriteScript(output, true, false, false, false, "G");
			}

			foreach (var permutation in permutations) {
				var suffix = string.Format(
					"{0}{1}{2}",
					permutation.ByRegion ? "R" : "",
					permutation.ByTeam ? "T" : "",
					permutation.ByChampion ? "C" : "");

				var filename = string.Format(
					"GenerateChampionStatsOverTime{0}.js", suffix);

				using (var output = new StreamWriter(filename)) {
					WriteScript(output, false, permutation.ByRegion, permutation.ByTeam, permutation.ByChampion, suffix);
				}
			}
		}

		private void WriteScript(TextWriter output, bool isGlobal, bool byRegion, bool byTeam, bool byChampion, string suffix) {

			output.Write(@"
//
// This script was generated by the CalculateChampionStatsScriptGenerator
// tool.
//
// This script aggregates per champion data for each region. It tries to
// gather as much data as possible and store it in a format that is as
// concise as possible to minimize download time when a browser requests
// the data.
//
// The data is placed into the ChampionStats collection. To export the
// individual documents use the MongoExtra utility to dump each champion
// document to its own json file that can be served by a web server.
//
// Dependencies:
//   GenerateMatchParticipants
//
db.MatchParticipants.aggregate(
  [
    // Project the data so that it include a special *win version of the
    // stats. This is only set to the value if the player actually won.
    // This is done so aggregate win stats can be calculated. Mongo will
    // ignore non-numbers during aggregation.
    {
      $project: {
        _id: false,
        matchId: true,
        region: true,
        platformId: true,
        matchCreation: true,
        matchDuration: true,
        matchVersion: true,
        teamId: true,
        participantId: true,
        spell1Id: true,
        spell2Id: true,
        championId: true,
        highestAchievedSeasonTier: true,
        masteries: true,
        runes: true,
        stats: true,
");

			foreach (var field in fields) {
				if (field.IsBoolean) {
					output.WriteLine("        {0}Win: {{ $cond: [ '$stats.winner', {{ $cmp: [ '$stats.{0}', false ] }}, null ] }},", field.Name);
				} else {
					output.WriteLine("        {0}Win: {{ $cond: [ '$stats.winner', '$stats.{0}', null ] }},", field.Name);
				}
			}

			output.Write(@"      }
    },
    // Gather the basic metrics for each champion in 1 hour groupings by region.
    {
      $group: {
        _id: {
");

			if (byRegion) {
				output.WriteLine(@"          region: '$region',");
			}

			if (byTeam) {
				output.WriteLine(@"          teamId: '$teamId',");
			}

			if (byChampion) {
				output.WriteLine(@"          championId: '$championId',");
			}

			output.Write(@"          month: { $month: '$matchCreation' },
          day: { $dayOfMonth: '$matchCreation' },
          hour: { $hour: '$matchCreation' }
        },
        timesPlayed: { $sum: 1 },
        wins: { $sum: { $cmp: [ '$stats.winner', false ] } },
");

			foreach (var field in fields) {
				var statFieldAccesor = "";
				var winFieldAccessor = string.Format("'${0}Win'", field.Name);

				if (field.IsBoolean) {
					statFieldAccesor = string.Format("{{ $cmp: [ '$stats.{0}', false ] }}", field.Name);
				} else {
					statFieldAccesor = string.Format("'$stats.{0}'", field.Name);
				}

				if (field.CalculateMin) {
					output.WriteLine("        {0}Min: {{ $min: {1} }},", field.Name, statFieldAccesor);
				}

				if (!field.IsBoolean) {
					output.WriteLine("        {0}Avg: {{ $avg: {1} }},", field.Name, statFieldAccesor);
				}

				if (field.CalculateMax) {
					output.WriteLine("        {0}Max: {{ $max: {1} }},", field.Name, statFieldAccesor);
				}

				if (field.CalculateTotal) {
					output.WriteLine("        {0}Sum: {{ $sum: {1} }},", field.Name, statFieldAccesor);
				}

				if (field.CalculateMin) {
					output.WriteLine("        {0}MinWin: {{ $min: {1} }},", field.Name, winFieldAccessor);
				}

				if (!field.IsBoolean) {
					output.WriteLine("        {0}AvgWin: {{ $avg: {1} }},", field.Name, winFieldAccessor);
				}

				if (field.CalculateMax) {
					output.WriteLine("        {0}MaxWin: {{ $max: {1} }},", field.Name, winFieldAccessor);
				}

				if (field.CalculateTotal) {
					output.WriteLine("        {0}SumWin: {{ $sum: {1} }},", field.Name, winFieldAccessor);
				}
			}

			output.Write(@"      }
    },
    // Order them by time now for the next step.
    {
      $sort: {
        '_id.month': 1,
        '_id.day': 1,
        '_id.hour': 1,
      }
    },
    // Combine all the hourly data into arrays. This will reduce the final
    // size of the JSON by deduping the key names.
    {
      $group: {
        _id: {
");

			if (isGlobal) {
				output.WriteLine(@"          global: 'global',");
			}

			if (byRegion) {
				output.WriteLine(@"          region: '$_id.region',");
			}

			if (byTeam) {
				output.WriteLine(@"          teamId: '$_id.teamId',");
			}

			if (byChampion) {
				output.WriteLine(@"          championId: '$_id.championId',");
			}

			output.Write(@"        },
        times: { $push: { $add: [ { $multiply: [ '$_id.month', 10000 ] }, { $multiply: [ '$_id.day', 100 ] }, '$_id.hour' ] } },
        timesPlayed: { $push: '$timesPlayed' },
        wins: { $push: '$wins' },
");

			foreach (var field in fields) {
				if (field.CalculateMin) {
					output.WriteLine("        {0}Min: {{ $push: '${0}Min' }},", field.Name);
				}

				if (!field.IsBoolean) {
					output.WriteLine("        {0}Avg: {{ $push: '${0}Avg' }},", field.Name);
				}

				if (field.CalculateMax) {
					output.WriteLine("        {0}Max: {{ $push: '${0}Max' }},", field.Name);
				}

				if (field.CalculateTotal) {
					output.WriteLine("        {0}Sum: {{ $push: '${0}Sum' }},", field.Name);
				}

				if (field.CalculateMin) {
					output.WriteLine("        {0}MinWin: {{ $push: '${0}MinWin' }},", field.Name);
				}

				if (!field.IsBoolean) {
					output.WriteLine("        {0}AvgWin: {{ $push: '${0}AvgWin' }},", field.Name);
				}

				if (field.CalculateMax) {
					output.WriteLine("        {0}MaxWin: {{ $push: '${0}MaxWin' }},", field.Name);
				}

				if (field.CalculateTotal) {
					output.WriteLine("        {0}SumWin: {{ $push: '${0}SumWin' }},", field.Name);
				}
			}

			output.Write(@"      }
    }
    ,
    {
");
			output.WriteLine("      $out: 'ChampionStatsOverTime{0}'", suffix);

			output.Write(@"    }
  ],
  {
    allowDiskUse: true
  }
);
");
		}
	}
}
